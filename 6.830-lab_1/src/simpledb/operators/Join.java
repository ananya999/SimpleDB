package simpledb.operators;
import java.util.ArrayList;
import java.util.NoSuchElementException;

import simpledb.exceptions.DbException;
import simpledb.exceptions.TransactionAbortedException;
import simpledb.predicates.JoinPredicate;
import simpledb.tuple.Tuple;
import simpledb.tuple.TupleDesc;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends AbstractDbIterator {

    private DbIterator leftChild;
    private DbIterator rightChild;
	private JoinPredicate p;
	private boolean open = false;
	private Tuple tuple_i;
	private Tuple tuple_j;
	private boolean next = true;
	
	private DbIterator leftChildCache;
	private ArrayList<Tuple> leftChildCacheList = new ArrayList<Tuple>();
	private boolean isCached = false;
	/**
     * Constructor.  Accepts to children to join and the predicate
     * to join them on
     *
     * @param p The predicate to use to join the children
     * @param child1 Iterator for the left(outer) relation to join
     * @param child2 Iterator for the right(inner) relation to join
     */
    public Join(JoinPredicate p, DbIterator child1, DbIterator child2) 
    {
    	this.leftChild = child1;
    	this.rightChild = child2;
    	this.p = p;
    	// init left child cache iterator 
    	leftChildCache = child1;
    }

    /**
     * @see simpledb.tuple.TupleDesc#combine(TupleDesc, TupleDesc) for possible implementation logic.
     */
    public TupleDesc getTupleDesc() 
    {
        return TupleDesc.combine(leftChild.getTupleDesc(), rightChild.getTupleDesc());
    }

    public void open() throws DbException, NoSuchElementException, TransactionAbortedException 
    {
    	leftChild.open();
    	rightChild.open();
    	open = true;
    }

    public void close() 
    {
    	super.close();
    	leftChild.close();
    	rightChild.close();
    	open = false;
    }

    public void rewind() throws DbException, TransactionAbortedException 
    {
    	super.close();
    	leftChild.rewind();
    	rightChild.rewind();
    }

    /**
     * Returns the next tuple generated by the join, or null if there are no more tuples.
     * Logically, this is the next tuple in r1 cross r2 that satisfies the join
     * predicate.  There are many possible implementations; the simplest is a
     * nested loops join.
     * <p>
     * Note that the tuples returned from this particular implementation of
     * Join are simply the concatenation of joining tuples from the left and
     * right relation. Therefore, if an equality predicate is used 
     * there will be two copies of the join attribute
     * in the results.  (Removing such duplicate columns can be done with an
     * additional projection operator if needed.)
     * <p>
     * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
     * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
     *
     * @return The next matching tuple.
     * @see JoinPredicate#filter
     */
    protected Tuple readNext() throws TransactionAbortedException, DbException 
    {
		Tuple crossTuple = null;
		if (!open) 
		{
			throw new DbException("Filter operator is closed");
		}
		outerloop:
		for (;!next || rightChild.hasNext();)
		{
			if (next) 
		 	{
				setLeftChildCache();
				tuple_i = rightChild.next();
				leftChildCache.rewind();
			}
			for (;leftChildCache.hasNext();)
			{
				tuple_j = leftChildCache.next();
				if (!isCached)
				{
					leftChildCacheList.add(tuple_j);
				}
				if (p.filter(tuple_j, tuple_i))
				{
					next = false;
					crossTuple =  Tuple.combine(tuple_j, tuple_i);
					break outerloop;
				}
			}
			next = true;
		}
		return crossTuple;
 	
    }

	private void setLeftChildCache() throws DbException, TransactionAbortedException {
		if (leftChildCacheList.isEmpty())
		{
			leftChildCache = leftChild;
		}
		else
		{
			if (!isCached)
			{
				leftChildCache = new TupleArrayIterator(leftChildCacheList);
				leftChildCache.open();
				isCached = true;
			}
		}
	}
}
